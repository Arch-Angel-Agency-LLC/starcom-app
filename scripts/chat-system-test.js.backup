#!/usr/bin/env node
/**
 * chat-system-test.js
 * 
 * A comprehensive test script to verify that the Starcom chat system
 * is functioning properly in development mode.
 * 
 * Tests the following chat types:
 * - Global Chat
 * - Group Chat
 * - Direct Messages (DM)
 * 
 * For each chat type, the script:
 * 1. Establishes a connection
 * 2. Creates/joins a channel
 * 3. Sends and receives messages
 * 4. Tests error handling
 * 5. Tests reconnection
 * 
 * Usage:
 *   npm run test:chat:demo
 * 
 * Environment variables:
 *   VERBOSE=true|false - Enable verbose logging
 *   TEST_TIMEOUT=30000 - Custom timeout in milliseconds
 *   TEST_PROVIDERS=gun,nostr,secure - Comma-separated list of providers to test
 */

import { createChatProvider } from '../src/lib/chat/ChatProviderFactory.js';
import { ChatErrorType } from '../src/lib/chat/utils/ChatErrorHandling.js';
import { v4 as uuidv4 } from 'uuid';
import chalk from 'chalk';
import fs from 'fs';
import path from 'path';

// Constants
const DEFAULT_TEST_TIMEOUT = 30000; // 30 seconds
const VERBOSE = process.env.VERBOSE === 'true';
const TEST_TIMEOUT = parseInt(process.env.TEST_TIMEOUT || DEFAULT_TEST_TIMEOUT.toString(), 10);
const TEST_PROVIDERS = process.env.TEST_PROVIDERS ? process.env.TEST_PROVIDERS.split(',') : ['gun', 'nostr', 'secure'];

// Test configuration
const TEST_CONFIG = {
  userA: {
    id: 'test-user-a',
    name: 'Test User A'
  },
  userB: {
    id: 'test-user-b',
    name: 'Test User B'
  },
  channels: {
    global: 'global-chat-test',
    group: 'group-chat-test',
    dm: 'dm-chat-test'
  },
  // Use environment variable or default providers
  providers: TEST_PROVIDERS,
  timeouts: {
    default: TEST_TIMEOUT,
    connect: 15000,
    message: 10000,
    networkResilience: 25000
  }
};

// Setup test report directory
const testReportDir = path.join(process.cwd(), 'test-results', 'chat-system');
if (!fs.existsSync(testReportDir)) {
  fs.mkdirSync(testReportDir, { recursive: true });
}

// Timestamp for logs
const timestamp = new Date().toISOString().replace(/:/g, '-');
const logFilePath = path.join(testReportDir, `chat-system-test-${timestamp}.log`);
const logStream = fs.createWriteStream(logFilePath, { flags: 'a' });

// Enhanced logging utilities
const logToFile = (message) => {
  const formattedMessage = `[${new Date().toISOString()}] ${message}\n`;
  logStream.write(formattedMessage);
};

const logSuccess = message => {
  console.log(chalk.green('✓ SUCCESS: ') + message);
  logToFile(`SUCCESS: ${message}`);
};

const logInfo = message => {
  console.log(chalk.blue('ℹ INFO: ') + message);
  logToFile(`INFO: ${message}`);
};

const logWarning = message => {
  console.log(chalk.yellow('⚠ WARNING: ') + message);
  logToFile(`WARNING: ${message}`);
};

const logError = (message, error) => {
  console.log(chalk.red('✗ ERROR: ') + message);
  logToFile(`ERROR: ${message}`);
  
  if (error) {
    console.error(error);
    
    // Log detailed error information
    if (error.stack) {
      logToFile(`ERROR STACK: ${error.stack}`);
    }
    
    // Log additional context for ChatError
    if (error.type && error.code) {
      logToFile(`ERROR DETAILS: Type=${error.type}, Code=${error.code}, Recoverable=${error.recoverable}`);
      
      if (error.details) {
        logToFile(`ERROR CONTEXT: ${JSON.stringify(error.details, null, 2)}`);
      }
    }
  }
};

const logHeader = message => {
  const header = '\n' + chalk.bgBlue.white(' ' + message + ' ');
  console.log(header);
  logToFile(`\n===== ${message} =====`);
};

const logVerbose = (message, data) => {
  if (VERBOSE) {
    console.log(chalk.gray('🔍 VERBOSE: ') + message);
    if (data) {
      console.log(chalk.gray(JSON.stringify(data, null, 2)));
    }
    logToFile(`VERBOSE: ${message}`);
    if (data) {
      logToFile(`VERBOSE DATA: ${JSON.stringify(data, null, 2)}`);
    }
  }
};

// Enhanced test utilities
const generateTestMessage = () => `Test message ${uuidv4().slice(0, 8)} at ${new Date().toISOString()}`;

const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

// Add timeout promise utility
const withTimeout = (promise, timeoutMs, operation) => {
  let timeoutId;
  const timeoutPromise = new Promise((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(new Error(`Operation timed out after ${timeoutMs}ms: ${operation}`));
    }, timeoutMs);
  });

  return Promise.race([
    promise,
    timeoutPromise
  ]).finally(() => {
    clearTimeout(timeoutId);
  });
};

// Test runner
async function runTests() {
  let successCount = 0;
  let failureCount = 0;
  const results = [];
  const startTime = Date.now();
  
  // Process catch unhandled errors
  process.on('unhandledRejection', (reason, promise) => {
    logError('Unhandled Promise Rejection', reason);
    logToFile(`UNHANDLED REJECTION: ${reason?.stack || JSON.stringify(reason)}`);
  });
  
  process.on('uncaughtException', (error) => {
    logError('Uncaught Exception', error);
    logToFile(`UNCAUGHT EXCEPTION: ${error?.stack || JSON.stringify(error)}`);
  });
  
  try {
    logHeader('STARCOM CHAT SYSTEM TEST SUITE');
    logInfo(`Starting comprehensive chat tests at ${new Date().toISOString()}`);
    logInfo(`Testing providers: ${TEST_CONFIG.providers.join(', ')}`);
    logInfo(`Test timeouts: default=${TEST_CONFIG.timeouts.default}ms, connect=${TEST_CONFIG.timeouts.connect}ms`);
    logInfo(`Verbose logging: ${VERBOSE ? 'enabled' : 'disabled'}`);
    logInfo(`Log file: ${logFilePath}`);
    
    for (const providerType of TEST_CONFIG.providers) {
      try {
        logHeader(`TESTING ${providerType.toUpperCase()} PROVIDER`);
        const providerStartTime = Date.now();
        
        await testChatProvider(providerType);
        
        const providerDuration = ((Date.now() - providerStartTime) / 1000).toFixed(2);
        logSuccess(`${providerType} provider tests completed successfully in ${providerDuration}s`);
        
        results.push({
          provider: providerType,
          success: true,
          duration: providerDuration
        });
        
        successCount++;
      } catch (error) {
        const errorMessage = `Failed tests for ${providerType} provider: ${error.message}`;
        logError(errorMessage, error);
        
        // Save more detailed error info
        results.push({
          provider: providerType,
          success: false,
          error: {
            message: error.message,
            type: error.type || 'unknown',
            code: error.code || 'unknown',
            stack: error.stack
          }
        });
        
        failureCount++;
      }
    }
  } catch (error) {
    logError('Fatal error during test execution', error);
    failureCount++;
  } finally {
    const duration = ((Date.now() - startTime) / 1000).toFixed(2);
    
    logHeader('TEST SUMMARY');
    console.log(`Duration: ${duration} seconds`);
    console.log(`Providers tested: ${TEST_CONFIG.providers.length}`);
    console.log(`Successful: ${successCount}`);
    console.log(`Failed: ${failureCount}`);
    
    // Save test report
    const reportPath = path.join(testReportDir, `chat-test-report-${timestamp}.json`);
    const report = {
      timestamp: new Date().toISOString(),
      duration: parseFloat(duration),
      totalTests: TEST_CONFIG.providers.length,
      success: successCount,
      failures: failureCount,
      providers: TEST_CONFIG.providers,
      results,
      configuration: {
        timeout: TEST_TIMEOUT,
        verbose: VERBOSE
      }
    };
    
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    logInfo(`Test report saved to ${reportPath}`);
    
    // Close log file
    logStream.end();
    
    if (failureCount === 0) {
      logSuccess('All chat providers tested successfully');
      process.exit(0);
    } else {
      logError('Some tests failed. See logs above for details.');
      process.exit(1);
    }
  }
}

// Test a specific chat provider
async function testChatProvider(providerType) {
  let providerA;
  let providerB;
  
  try {
    logInfo(`Creating ${providerType} provider instances...`);
    
    // Create two provider instances to simulate two users
    // Set log level to debug if verbose mode is enabled
    const logOptions = { 
      logLevel: VERBOSE ? 'debug' : 'info',
      maxRetries: 3,
      retryBackoffMs: 500
    };
    
    [providerA, providerB] = await Promise.all([
      withTimeout(
        createChatProvider({ 
          type: providerType, 
          options: { 
            userId: TEST_CONFIG.userA.id,
            userName: TEST_CONFIG.userA.name,
            ...logOptions
          }
        }),
        TEST_CONFIG.timeouts.connect,
        `Create provider A (${providerType})`
      ),
      withTimeout(
        createChatProvider({ 
          type: providerType, 
          options: { 
            userId: TEST_CONFIG.userB.id,
            userName: TEST_CONFIG.userB.name,
            ...logOptions
          }
        }),
        TEST_CONFIG.timeouts.connect,
        `Create provider B (${providerType})`
      )
    ]);
    
    logSuccess(`Created ${providerType} provider instances`);
    logVerbose('Provider instances', {
      providerA: {
        userId: TEST_CONFIG.userA.id,
        features: providerA.getSupportedFeatures?.() || []
      },
      providerB: {
        userId: TEST_CONFIG.userB.id,
        features: providerB.getSupportedFeatures?.() || []
      }
    });
    
    // Register error handlers
    providerA.on('error', (error) => {
      logVerbose(`Provider A error event: ${error.message}`, {
        type: error.type,
        code: error.code,
        recoverable: error.recoverable
      });
    });
    
    providerB.on('error', (error) => {
      logVerbose(`Provider B error event: ${error.message}`, {
        type: error.type,
        code: error.code,
        recoverable: error.recoverable
      });
    });
    
    // Connect both providers with timeout
    logInfo('Connecting providers...');
    
    try {
      await Promise.all([
        withTimeout(providerA.connect(), TEST_CONFIG.timeouts.connect, `Connect provider A (${providerType})`),
        withTimeout(providerB.connect(), TEST_CONFIG.timeouts.connect, `Connect provider B (${providerType})`)
      ]);
      
      if (providerA.isConnected() && providerB.isConnected()) {
        logSuccess('Both providers connected successfully');
      } else {
        throw new Error(`Failed to connect providers: A=${providerA.isConnected()}, B=${providerB.isConnected()}`);
      }
    } catch (error) {
      logError('Connection failed', error);
      // Add connection state to error details
      const details = {
        providerA: {
          connected: providerA.isConnected(),
          state: providerA.getConnectionState?.()
        },
        providerB: {
          connected: providerB.isConnected(),
          state: providerB.getConnectionState?.()
        }
      };
      logVerbose('Connection state details', details);
      throw error;
    }
    
    // Run tests with detailed progress reporting
    const tests = [
      { name: 'Global Chat', fn: () => testGlobalChat(providerA, providerB) },
      { name: 'Group Chat', fn: () => testGroupChat(providerA, providerB) },
      { name: 'Direct Messaging', fn: () => testDirectMessaging(providerA, providerB) },
      { name: 'Error Handling', fn: () => testErrorHandling(providerA) },
      { name: 'Network Resilience', fn: () => testNetworkResilience(providerA, providerB) }
    ];
    
    for (const test of tests) {
      logInfo(`Starting test: ${test.name}...`);
      const testStartTime = Date.now();
      
      try {
        await test.fn();
        const testDuration = ((Date.now() - testStartTime) / 1000).toFixed(2);
        logSuccess(`Completed test: ${test.name} in ${testDuration}s`);
      } catch (error) {
        const testDuration = ((Date.now() - testStartTime) / 1000).toFixed(2);
        logError(`Failed test: ${test.name} after ${testDuration}s`, error);
        
        // Add contextual information about the test failure
        logToFile(`TEST FAILURE CONTEXT: ${test.name} for provider ${providerType}`);
        
        // Rethrow with enhanced error message
        const enhancedError = new Error(`${test.name} test failed: ${error.message}`);
        enhancedError.stack = error.stack;
        enhancedError.originalError = error;
        throw enhancedError;
      }
    }
    
    // Disconnect providers
    logInfo('Disconnecting providers...');
    await Promise.allSettled([
      providerA.disconnect(),
      providerB.disconnect()
    ]);
    
    logSuccess('Providers disconnected successfully');
    
  } catch (error) {
    // Always try to disconnect providers on error
    if (providerA || providerB) {
      logInfo('Attempting to disconnect providers after error...');
      
      if (providerA) {
        try {
          await providerA.disconnect();
        } catch (disconnectError) {
          logVerbose(`Error disconnecting provider A: ${disconnectError.message}`);
        }
      }
      
      if (providerB) {
        try {
          await providerB.disconnect();
        } catch (disconnectError) {
          logVerbose(`Error disconnecting provider B: ${disconnectError.message}`);
        }
      }
    }
    
    // Re-throw the original error
    throw error;
  }
}

// Test Global Chat functionality
async function testGlobalChat(providerA, providerB) {
  logHeader('TESTING GLOBAL CHAT');
  const channelId = TEST_CONFIG.channels.global;
  
  // Create or join global channel
  logInfo(`Creating/joining global channel: ${channelId}...`);
  try {
    // User A creates the channel
    const channel = await withTimeout(
      providerA.createChannel(
        'Global Test Channel', 
        'global', 
        []
      ),
      TEST_CONFIG.timeouts.default,
      'Create global channel'
    );
    logSuccess(`User A created global channel: ${channel.id}`);
    logVerbose('Channel details', channel);
  } catch (error) {
    // Channel might already exist
    logWarning(`Could not create channel: ${error.message}`);
    logInfo('Attempting to join instead...');
  }
  
  // Both users join the channel
  try {
    await withTimeout(
      Promise.all([
        providerA.joinChannel(channelId),
        providerB.joinChannel(channelId)
      ]),
      TEST_CONFIG.timeouts.default,
      'Join global channel'
    );
    logSuccess('Both users joined global channel');
  } catch (error) {
    logError('Failed to join global channel', error);
    throw new Error(`Channel join failed: ${error.message}`);
  }
  
  // Set up message listener for user B
  let messageReceived = false;
  const testMessage = generateTestMessage();
  const messagePromise = new Promise((resolve) => {
    const unsubscribe = providerB.subscribeToMessages(channelId, (message) => {
      logVerbose('Received message in global channel', message);
      
      if (message.senderId === TEST_CONFIG.userA.id && message.content === testMessage) {
        messageReceived = true;
        logSuccess(`User B received message from User A: ${message.content}`);
        
        // Verify message properties for robustness
        const messageHasRequiredProps = 
          message.id && 
          message.channelId === channelId &&
          message.timestamp &&
          message.senderId === TEST_CONFIG.userA.id;
        
        if (!messageHasRequiredProps) {
          logWarning('Message is missing required properties', {
            hasId: !!message.id,
            hasCorrectChannel: message.channelId === channelId,
            hasTimestamp: !!message.timestamp,
            hasSenderId: message.senderId === TEST_CONFIG.userA.id
          });
        }
        
        unsubscribe();
        resolve(message);
      }
    });
    
    // Add timeout for message reception
    setTimeout(() => {
      if (!messageReceived) {
        unsubscribe();
        resolve(null); // Will be handled below as a timeout
      }
    }, TEST_CONFIG.timeouts.message);
  });
  
  // User A sends a message
  logInfo('User A sending message to global channel...');
  try {
    const sentMessage = await withTimeout(
      providerA.sendMessage(channelId, testMessage),
      TEST_CONFIG.timeouts.default,
      'Send message to global channel'
    );
    logSuccess(`User A sent message: ${sentMessage.id}`);
    logVerbose('Sent message details', sentMessage);
  } catch (error) {
    logError('Failed to send message to global channel', error);
    throw new Error(`Message send failed: ${error.message}`);
  }
  
  // Wait for message to be received
  logInfo('Waiting for message to be received...');
  const receivedMessage = await messagePromise;
  
  if (!receivedMessage) {
    throw new Error(`Message was not received within timeout (${TEST_CONFIG.timeouts.message}ms)`);
  }
  
  // Get channel messages to verify persistence
  logInfo('Retrieving channel messages to verify persistence...');
  try {
    const messages = await withTimeout(
      providerB.getMessages(channelId),
      TEST_CONFIG.timeouts.default,
      'Get messages from global channel'
    );
    
    const foundMessage = messages.some(msg => 
      msg.senderId === TEST_CONFIG.userA.id && 
      msg.content === testMessage
    );
    
    if (foundMessage) {
      logSuccess('Message was successfully persisted and retrieved');
      logVerbose(`Retrieved ${messages.length} messages from channel`);
    } else {
      logWarning('Message was not found in channel history', {
        messageContent: testMessage,
        totalMessages: messages.length
      });
      
      // This is a soft failure - log but don't throw
      if (messages.length > 0) {
        logVerbose('Retrieved messages', messages.slice(0, 3));
      }
    }
  } catch (error) {
    logWarning(`Could not verify message persistence: ${error.message}`);
  }
  
  logSuccess('Global chat test completed successfully');
}
  
  while (Date.now() - startTime < messageTimeout) {
    if (messageReceived) {
      receivedWithinTimeout = true;
      break;
    }
    await delay(500);
  }
  
  // Verify message was received
  if (!receivedWithinTimeout) {
    throw new Error(`Global chat message was not received by User B within ${messageTimeout}ms timeout - this is a real failure indicating message delivery problems`);
  }
  
  // Clean up subscription
  unsubscribe();
  
  // Get messages
  const messagesA = await providerA.getMessages(channelId, 10);
  logSuccess(`User A retrieved ${messagesA.length} messages from global channel`);
  
  // Verify sent message is in the retrieved messages
  const foundMessage = messagesA.find(m => m.content === testMessage);
  if (!foundMessage) {
    throw new Error('Sent message not found in retrieved messages');
  }
  
  logSuccess('Global chat functionality verified');
}

// Test Group Chat functionality
async function testGroupChat(providerA, providerB) {
  logHeader('TESTING GROUP CHAT');
  const groupName = 'Test Group';
  const channelId = TEST_CONFIG.channels.group;
  
  // User A creates a group chat
  logInfo(`User A creating group chat: ${groupName}...`);
  try {
    const channel = await providerA.createChannel(
      groupName, 
      'team', 
      [TEST_CONFIG.userA.id, TEST_CONFIG.userB.id]
    );
    logSuccess(`Group chat created: ${channel.id}`);
  } catch (error) {
    // Group might already exist
    logWarning(`Could not create group: ${error.message}`);
    logInfo('Attempting to join instead...');
  }
  
  // Both users join the group
  await providerA.joinChannel(channelId);
  await providerB.joinChannel(channelId);
  logSuccess('Both users joined group chat');
  
  // Set up message listener for user B
  let messageReceived = false;
  const testMessage = generateTestMessage();
  const unsubscribe = providerB.subscribeToMessages(channelId, (message) => {
    if (message.senderId === TEST_CONFIG.userA.id && message.content === testMessage) {
      messageReceived = true;
      logSuccess(`User B received group message from User A: ${message.content}`);
    }
  });
  
  // User A sends a message to the group
  logInfo('User A sending message to group chat...');
  const sentMessage = await providerA.sendMessage(channelId, testMessage);
  logSuccess(`User A sent group message: ${sentMessage.id}`);
  
  // Wait for message to be received
  logInfo('Waiting for group message to be received...');
  let receivedWithinTimeout = false;
  const startTime = Date.now();
  const messageTimeout = 10000; // 10 seconds timeout
  
  while (Date.now() - startTime < messageTimeout) {
    if (messageReceived) {
      receivedWithinTimeout = true;
      break;
    }
    await delay(500);
  }
  
  // Verify message was received
  if (!receivedWithinTimeout) {
    throw new Error(`Group chat message was not received by User B within ${messageTimeout}ms timeout - this is a real failure indicating message delivery problems in group chat`);
  }
  
  // Clean up subscription
  unsubscribe();
  
  // Get users in the group
  const users = await providerA.getUsers(channelId);
  logSuccess(`Retrieved ${users.length} users in the group chat`);
  
  // Verify both users are in the group
  const userAFound = users.some(u => u.id === TEST_CONFIG.userA.id);
  const userBFound = users.some(u => u.id === TEST_CONFIG.userB.id);
  
  if (!userAFound || !userBFound) {
    throw new Error('Not all users found in group member list');
  }
  
  logSuccess('Group chat functionality verified');
}

// Test Direct Messaging functionality
async function testDirectMessaging(providerA, providerB) {
  logHeader('TESTING DIRECT MESSAGES');
  const dmChannelId = `dm-${TEST_CONFIG.userA.id}-${TEST_CONFIG.userB.id}`;
  
  // User A creates a DM channel
  logInfo('User A creating DM channel...');
  try {
    const channel = await providerA.createChannel(
      `DM with ${TEST_CONFIG.userB.name}`, 
      'direct', 
      [TEST_CONFIG.userA.id, TEST_CONFIG.userB.id]
    );
    logSuccess(`DM channel created: ${channel.id}`);
  } catch (error) {
    // DM might already exist
    logWarning(`Could not create DM channel: ${error.message}`);
    logInfo('Attempting to join instead...');
  }
  
  // Both users join the DM channel
  await providerA.joinChannel(dmChannelId);
  await providerB.joinChannel(dmChannelId);
  logSuccess('Both users joined DM channel');
  
  // Set up message listener for user B
  let messageReceived = false;
  const testMessage = generateTestMessage();
  const unsubscribe = providerB.subscribeToMessages(dmChannelId, (message) => {
    if (message.senderId === TEST_CONFIG.userA.id && message.content === testMessage) {
      messageReceived = true;
      logSuccess(`User B received DM from User A: ${message.content}`);
    }
  });
  
  // User A sends a DM
  logInfo('User A sending direct message...');
  const sentMessage = await providerA.sendMessage(dmChannelId, testMessage);
  logSuccess(`User A sent DM: ${sentMessage.id}`);
  
  // Wait for message to be received
  logInfo('Waiting for DM to be received...');
  let receivedWithinTimeout = false;
  const startTime = Date.now();
  const messageTimeout = 10000; // 10 seconds timeout
  
  while (Date.now() - startTime < messageTimeout) {
    if (messageReceived) {
      receivedWithinTimeout = true;
      break;
    }
    await delay(500);
  }
  
  // Verify message was received
  if (!receivedWithinTimeout) {
    throw new Error(`Direct message was not received by User B within ${messageTimeout}ms timeout - this is a real failure indicating message delivery problems in DM chat`);
  }
  
  // Clean up subscription
  unsubscribe();
  
  // Get list of all channels
  const channels = await providerA.getChannels();
  logSuccess(`Retrieved ${channels.length} channels`);
  
  // Verify DM channel exists in the list
  const dmChannelFound = channels.some(c => c.id === dmChannelId);
  if (!dmChannelFound) {
    throw new Error('DM channel not found in channel list');
  }
  
  // Test marking messages as read
  logInfo('Testing mark as read functionality...');
  await providerB.markMessagesAsRead(dmChannelId, [sentMessage.id]);
  logSuccess('Message marked as read');
  
  logSuccess('Direct messaging functionality verified');
}

// Test error handling
async function testErrorHandling(provider) {
  logHeader('TESTING ERROR HANDLING');
  
  // Test feature detection
  logInfo('Testing feature detection...');
  const supportedFeatures = provider.getSupportedFeatures();
  logSuccess(`Provider supports ${supportedFeatures.length} features`);
  
  const hasConnect = supportedFeatures.includes('connect');
  const hasSendMessage = supportedFeatures.includes('sendMessage');
  
  if (!hasConnect || !hasSendMessage) {
    throw new Error('Provider missing essential features');
  }
  
  // Test various error scenarios
  
  // 1. Invalid channel ID
  logInfo('Testing error handling for empty channel ID...');
  let invalidChannelErrorThrown = false;
  try {
    await provider.sendMessage('', 'This should fail');
    throw new Error('FAILURE: Empty channel ID did not throw error');
  } catch (error) {
    invalidChannelErrorThrown = true;
    logSuccess(`Properly handled error: ${error.message}`);
    
    // Verify error is a ChatError with proper structure
    const expectedTypes = ['INVALID_INPUT', 'invalid_input'];
    if (error.type && (error.type === ChatErrorType.INVALID_INPUT || expectedTypes.includes(error.type))) {
      logSuccess(`Error has correct type: ${error.type}`);
    } else if (error.type) {
      logWarning(`Error has unexpected type: ${error.type}, expected one of: ${expectedTypes.join(', ')}`);
    } else {
      logWarning('Error does not have type property from ChatError');
    }
    
    if (error.code) {
      logSuccess(`Error has code: ${error.code}`);
    } else {
      logWarning('Error does not have code property from ChatError');
    }
  }
  
  if (!invalidChannelErrorThrown) {
    throw new Error('Provider failed to throw error for invalid input');
  }
  
  // 2. Invalid message content
  logInfo('Testing error handling for null message content...');
  let invalidContentErrorThrown = false;
  try {
    await provider.sendMessage('test-channel', null);
    throw new Error('FAILURE: Null message content did not throw error');
  } catch (error) {
    invalidContentErrorThrown = true;
    logSuccess(`Properly handled error: ${error.message}`);
  }
  
  if (!invalidContentErrorThrown) {
    throw new Error('Provider failed to throw error for invalid content');
  }
  
  // 3. Unsupported feature
  logInfo('Testing unsupported feature handling...');
  const nonExistentFeature = 'nonExistentFeature' + Date.now();
  if (!supportedFeatures.includes(nonExistentFeature)) {
    logSuccess(`Correctly detected that ${nonExistentFeature} is not supported`);
    
    // Try to call a method that might not be supported
    if (!supportedFeatures.includes('uploadAttachment')) {
      try {
        // Create a simple mock file
        const mockFile = new File(['test'], 'test.txt', { type: 'text/plain' });
        await provider.uploadAttachment(mockFile);
        logWarning('Expected error was not thrown for unsupported uploadAttachment');
      } catch (error) {
        logSuccess(`Properly handled unsupported feature: ${error.message}`);
        
        // Check if proper error type
        if (error.type === ChatErrorType.FEATURE_NOT_SUPPORTED) {
          logSuccess('Error correctly identified as FEATURE_NOT_SUPPORTED');
        } else {
          logWarning(`Unsupported feature error has unexpected type: ${error.type}`);
        }
      }
    }
  }
  
  // 4. Test circuit breaker
  logInfo('Testing circuit breaker (simulating multiple failures)...');
  let failureCount = 0;
  let circuitBreakerTriggered = false;
  
  try {
    for (let i = 0; i < 7; i++) {
      try {
        // Try to get a non-existent user with random ID to trigger failure
        await provider.getUserById('non-existent-user-' + Date.now());
      } catch (error) {
        failureCount++;
        
        // Check if this error is from circuit breaker
        if (error.code === 'circuit_open') {
          circuitBreakerTriggered = true;
          logSuccess(`Circuit breaker opened after ${failureCount} failures`);
          break;
        }
        
        logInfo(`Failure ${failureCount}: ${error.message}`);
      }
      
      // Short delay between attempts
      await delay(100);
    }
    
    if (circuitBreakerTriggered) {
      logSuccess('Circuit breaker test passed - circuit opened after multiple failures');
      
      // Wait for circuit to potentially reset
      logInfo('Waiting briefly for circuit breaker cooldown...');
      await delay(1000);
      
      // Try again after delay, should either work or give a circuit_open error with time remaining
      try {
        await provider.getUserById('test-user');
        logInfo('Circuit breaker reset or request succeeded after cooldown');
      } catch (error) {
        if (error.code === 'circuit_open' && error.details?.timeUntilReset) {
          logSuccess(`Circuit still open with ${error.details.timeUntilReset}ms until reset`);
        } else {
          logWarning(`Unexpected error after circuit breaker: ${error.message}`);
        }
      }
    } else if (failureCount > 0) {
      logWarning(`Experienced ${failureCount} failures but circuit breaker did not trigger`);
    } else {
      logWarning('No failures occurred during circuit breaker test');
    }
  } catch (error) {
    logWarning(`Circuit breaker test interrupted: ${error.message}`);
  }
  
  logSuccess('Error handling verification completed');
}

// Test network disruption and recovery
async function testNetworkResilience(providerA, providerB) {
  logHeader('TESTING NETWORK RESILIENCE');
  const channelId = TEST_CONFIG.channels.global;
  
  // Ensure we're connected
  if (!providerA.isConnected()) {
    await providerA.connect();
  }
  
  if (!providerB.isConnected()) {
    await providerB.connect();
  }
  
  // Test message before disruption
  logInfo('Testing message delivery before simulating network issues...');
  const preSentMessage = await providerA.sendMessage(channelId, 'Message before network disruption');
  logSuccess('Pre-disruption message sent successfully');
  
  // Force disconnect and test reconnection
  logInfo('Simulating network disruption...');
  
  // Try to disconnect directly
  try {
    // Different approaches to simulate disruption
    if (typeof providerA._simulateNetworkDisruption === 'function') {
      // If the adapter has a test method, use it
      providerA._simulateNetworkDisruption();
      logInfo('Used provider-specific network disruption simulation');
    } else {
      // Otherwise force a disconnect
      await providerA.disconnect();
      logInfo('Forced provider disconnect to simulate disruption');
    }
    
    // Verify disconnected state
    if (!providerA.isConnected()) {
      logSuccess('Provider successfully disconnected');
    } else {
      logWarning('Provider still shows as connected after disconnect attempt');
    }
    
    // Wait a moment
    await delay(1000);
    
    // Try to send a message while disconnected
    try {
      await providerA.sendMessage(channelId, 'This should fail or trigger reconnect');
      logInfo('Message sent during disconnection - provider may have auto-reconnected');
    } catch (error) {
      logInfo(`Expected error occurred during disconnection: ${error.message}`);
      
      // Check if error has proper structure
      if (error.type) {
        logSuccess(`Error has proper type: ${error.type}`);
      } else {
        logWarning('Error lacks proper ChatError structure');
      }
    }
    
    // Attempt reconnection
    logInfo('Attempting reconnection...');
    await providerA.connect();
    
    if (providerA.isConnected()) {
      logSuccess('Reconnection successful');
    } else {
      throw new Error('Failed to reconnect after network disruption');
    }
    
    // Test sending a message after reconnection
    logInfo('Testing message delivery after reconnection...');
    const postMessage = await providerA.sendMessage(
      channelId, 
      'Message after network disruption and reconnection'
    );
    logSuccess('Post-disruption message sent successfully');
    
    // Verify messages can be retrieved after reconnection
    const messages = await providerA.getMessages(channelId, 10);
    const foundPreMessage = messages.some(m => m.id === preSentMessage.id);
    const foundPostMessage = messages.some(m => m.id === postMessage.id);
    
    if (foundPreMessage) {
      logSuccess('Pre-disruption message was preserved/retrieved after reconnection');
    } else {
      logWarning('Pre-disruption message was not found after reconnection');
    }
    
    if (foundPostMessage) {
      logSuccess('Post-disruption message was successfully stored');
    } else {
      throw new Error('Post-disruption message was not found in retrieved messages');
    }
    
  } catch (error) {
    // This test may fail legitimately for some providers that don't support
    // disconnection simulation or auto-reconnection
    logWarning(`Network resilience test encountered an error: ${error.message}`);
    logInfo('This may be expected behavior for this provider, continuing tests...');
  }
  
  logSuccess('Network resilience testing completed');
}

// Run tests
runTests().catch(error => {
  console.error('Test suite failed:', error);
  process.exit(1);
});
