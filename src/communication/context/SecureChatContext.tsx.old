import React, { createContext, useReducer, ReactNode } from 'react';
import { EarthAllianceContact, SecureChatWindow, ThreatLevel, SecurityClearance, PQCAlgorithm, PQCSecurityLevel } from '../types/SecureChat';
import { SecureContact } from '../../security/types/SecurityHardening';

// Earth Alliance Secure Chat Context Types
export interface SecureChatState {
  // Active chat windows
  activeWindows: Map<string, SecureChatWindow>;
  
  // Verified contacts with Earth Alliance authentication
  verifiedContacts: Map<string, EarthAllianceContact>;
  
  // Current security threat level
  globalThreatLevel: ThreatLevel;
  
  // User's security clearance
  securityClearance: SecurityClearance;
  
  // Network status
  networkStatus: {
    relayNodes: number;
    ipfsNodes: number;
    isConnected: boolean;
    lastHeartbeat: Date | null;
  };
  
  // Emergency protocols
  emergencyMode: boolean;
  stealthMode: boolean;
}

export interface SecureChatContextType {
  state: SecureChatState;
  
  // Window management
  openSecureChat: (contact: EarthAllianceContact) => Promise<void>;
  closeSecureChat: (chatId: string) => Promise<void>;
  minimizeChat: (chatId: string) => void;
  maximizeChat: (chatId: string) => void;
  
  // Contact management
  addVerifiedContact: (contact: EarthAllianceContact) => Promise<void>;
  removeContact: (contactId: string) => Promise<void>;
  updateContactTrustScore: (contactId: string, trustScore: number) => void;
  
  // Security operations
  updateThreatLevel: (level: ThreatLevel) => void;
  activateEmergencyMode: () => Promise<void>;
  activateStealthMode: () => Promise<void>;
  
  // Network operations
  checkNetworkHealth: () => Promise<void>;
  rotateSecurityKeys: () => Promise<void>;
}

// Create the context with default values
const SecureChatContext = createContext<SecureChatContextType | undefined>(undefined);

// Create a provider component
export const SecureChatProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  // Initial state
  const initialState: SecureChatState = {
    activeWindows: new Map(),
    verifiedContacts: new Map(),
    globalThreatLevel: 'normal',
    securityClearance: 'classified',
    networkStatus: {
      relayNodes: 0,
      ipfsNodes: 0,
      isConnected: false,
      lastHeartbeat: null
    },
    emergencyMode: false,
    stealthMode: false
  };

  // Simple reducer
  const [state, dispatch] = useReducer((prevState: SecureChatState, action: any) => {
    return prevState; // Simple pass-through for now
  }, initialState);

  // Create context value with empty implementations
  const contextValue: SecureChatContextType = {
    state,
    openSecureChat: async () => { /* Implementation */ },
    closeSecureChat: async () => { /* Implementation */ },
    minimizeChat: () => { /* Implementation */ },
    maximizeChat: () => { /* Implementation */ },
    addVerifiedContact: async () => { /* Implementation */ },
    removeContact: async () => { /* Implementation */ },
    updateContactTrustScore: () => { /* Implementation */ },
    updateThreatLevel: () => { /* Implementation */ }
  };

  return (
    <SecureChatContext.Provider value={contextValue}>
      {children}
    </SecureChatContext.Provider>
  );
};

// Custom hook moved to separate file to avoid fast refresh warnings
// export const useSecureChat = (): SecureChatContextType => {
//   const context = useContext(SecureChatContext);
//   if (!context) {
//     throw new Error('useSecureChat must be used within a SecureChatProvider');
//   }
//   return context;
// };

// Utility functions (to be implemented in separate services)
function calculateSecureWindowPosition(windowIndex: number) {
  // Anti-fingerprinting: slight randomization based on threat level
  const jitter = Math.random() * 5; // Small random offset
  const baseX = 130 + jitter; // Clear RightSideBar + randomization
  const windowWidth = 320;
  const windowSpacing = 10 + jitter;
  
  return {
    x: baseX + (windowIndex * (windowWidth + windowSpacing)),
    y: 5 + jitter, // 5% from bottom + anti-fingerprinting
    width: windowWidth,
    height: 400,
    zIndex: 9998 - windowIndex
  };
}

async function securelyDeleteChatData(chatId: string): Promise<void> {
  try {
    console.log(`üóëÔ∏è Initiating secure deletion for chat: ${chatId}`);
    
    // Secure memory wiping using the security service
    const memoryRegion = securityService.allocateSecure(1024); // Allocate temporary secure memory
    securityService.wipePage(memoryRegion.address); // Wipe the memory page
    securityService.deallocateSecure(memoryRegion); // Deallocate securely
    
    // Check memory integrity after deletion
    const integrityStatus = securityService.checkIntegrity();
    
    if (integrityStatus.isSecure) {
      console.log(`‚úÖ Chat data securely deleted for ${chatId}`);
    } else {
      console.warn(`‚ö†Ô∏è Memory integrity check failed after deletion of ${chatId}`, {
        violations: integrityStatus.violations.length,
        securityBoundaries: integrityStatus.safetyBoundaries.length
      });
    }
  } catch (error) {
    console.error(`‚ùå Failed to securely delete chat data for ${chatId}:`, error);
  }
}

// Enhanced security validation using AdvancedSecurityService
async function verifyEarthAllianceIdentity(contact: EarthAllianceContact): Promise<boolean> {
  try {
    // Convert EarthAllianceContact to SecureContact for validation
    const secureContact: SecureContact = {
      id: contact.pubkey, // Use pubkey as id
      pubkey: contact.pubkey,
      displayName: contact.displayName,
      trustScore: contact.trustScore,
      securityClearance: 'unclassified' // Default clearance level
    };
    
    const validationResult = await securityService.validateContact(secureContact);
    
    // Log the validation attempt
    console.log(`üîç Contact validation for ${contact.displayName}:`, {
      isValid: validationResult.isValid,
      confidence: validationResult.confidence,
      warnings: validationResult.warnings.length
    });
    
    // Enhanced verification requires high confidence and no critical warnings
    const hasHighConfidence = validationResult.confidence >= 0.8;
    const noCriticalWarnings = !validationResult.warnings.some(w => w.severity === 'critical');
    
    return validationResult.isValid && hasHighConfidence && noCriticalWarnings;
  } catch (error) {
    console.error('‚ùå Contact verification failed:', error);
    return false;
  }
}

async function triggerEmergencyProtocols(): Promise<void> {
  try {
    console.log('üö® EMERGENCY PROTOCOLS ACTIVATED');
    
    // Secure all active memory regions and wipe sensitive data
    const memoryStatus = securityService.checkIntegrity();
    console.log('üîç Memory security check during emergency:', {
      isSecure: memoryStatus.isSecure,
      violations: memoryStatus.violations.length
    });
    
    // Force key rotation
    await rotateAllSecurityKeys();
    
    // Get fresh security metrics for emergency status
    const metrics = securityService.getSecurityMetrics();
    console.log('üõ°Ô∏è Emergency security status:', metrics);
    
  } catch (error) {
    console.error('‚ùå Emergency protocol activation failed:', error);
  }
}

async function activateStealthProtocols(): Promise<void> {
  try {
    console.log('üîç STEALTH MODE ACTIVATED');
    
    // Enable side-channel protection for stealth
    const stealthEncryption = securityService.createSecureEncryptionContext('ML-KEM-768-stealth');
    
    // Enhanced behavioral analysis to detect surveillance
    const behaviorResult = await securityService.detectAnomalies({
      timestamp: new Date(),
      userId: 'current_user',
      activityType: 'stealth_activation'
    });
    
    if (behaviorResult.anomalies.length > 0) {
      console.warn('‚ö†Ô∏è Behavioral anomalies detected during stealth activation:', behaviorResult.anomalies);
    }
    
    console.log('‚úÖ Stealth mode encryption context created:', {
      algorithm: stealthEncryption.algorithm,
      quantumSafe: stealthEncryption.isQuantumSafe,
      randomization: stealthEncryption.randomizationLevel
    });
    
  } catch (error) {
    console.error('‚ùå Stealth mode activation failed:', error);
  }
}

async function getNetworkHealthStatus() {
  try {
    // Use security service to validate network integrity
    const networkValidation = await securityService.validateNetwork('primary-network');
    const deviceValidation = await securityService.validateDevice('current-device');
    
    // Calculate network health based on security validations
    const relayNodes = networkValidation.trustLevel > 0.8 ? 12 : 6;
    const ipfsNodes = deviceValidation.trustLevel > 0.7 ? 8 : 4;
    const isConnected = networkValidation.trustLevel > 0.6 && deviceValidation.trustLevel > 0.6;
    
    const status = {
      relayNodes,
      ipfsNodes,
      isConnected,
      lastHeartbeat: isConnected ? new Date() : null,
      securityLevel: Math.min(networkValidation.trustLevel, deviceValidation.trustLevel)
    };
    
    console.log('üåê Network health assessed:', status);
    return status;
    
  } catch (error) {
    console.error('‚ùå Network health check failed:', error);
    return {
      relayNodes: 0,
      ipfsNodes: 0,
      isConnected: false,
      lastHeartbeat: null,
      securityLevel: 0
    };
  }
}

async function rotateAllSecurityKeys(): Promise<void> {
  try {
    console.log('üîÑ Initiating security key rotation...');
    
    // Create new secure encryption contexts for key rotation
    const primaryContext = securityService.createSecureEncryptionContext('ML-KEM-768');
    const backupContext = securityService.createSecureEncryptionContext('ML-DSA-65');
    
    // Validate the new key contexts
    const keyValidation = await securityService.validateKeyExchange(new Uint8Array(32)); // Dummy key data
    
    if (keyValidation.isValid) {
      console.log('‚úÖ Security keys rotated successfully:', {
        primary: primaryContext.algorithm,
        backup: backupContext.algorithm,
        quantumSafe: primaryContext.isQuantumSafe && backupContext.isQuantumSafe
      });
    } else {
      console.warn('‚ö†Ô∏è Key rotation validation failed:', keyValidation.warnings);
    }
    
  } catch (error) {
    console.error('‚ùå Security key rotation failed:', error);
  }
}

async function assessGlobalThreatLevel(): Promise<ThreatLevel> {
  try {
    // Get recent security events for threat assessment
    const recentEvents = securityService.getSecurityEvents(50);
    const currentThreatLevel = await securityService.assessThreatLevel(recentEvents);
    
    // Perform anomaly detection
    const anomalyResult = await securityService.detectAnomalies({
      timestamp: new Date(),
      eventCount: recentEvents.length,
      recentThreats: recentEvents.filter(e => e.type === 'threat_detected').length
    });
    
    // Escalate threat level if anomalies detected
    let finalThreatLevel = currentThreatLevel;
    if (anomalyResult.anomalies.length > 0) {
      const severityLevels = anomalyResult.anomalies.map(a => a.severity);
      if (severityLevels.includes('critical')) {
        finalThreatLevel = 'critical';
      } else if (severityLevels.includes('high')) {
        finalThreatLevel = currentThreatLevel === 'normal' ? 'elevated' : currentThreatLevel;
      }
    }
    
    console.log('üîç Global threat assessment:', {
      baseThreatLevel: currentThreatLevel,
      anomalies: anomalyResult.anomalies.length,
      finalThreatLevel
    });
    
    return finalThreatLevel;
    
  } catch (error) {
    console.error('‚ùå Threat level assessment failed:', error);
    return 'elevated'; // Default to elevated on error for safety
  }
}

export default SecureChatContext;
