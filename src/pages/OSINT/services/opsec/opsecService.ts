/**
 * OSINT OPSEC Service
 * 
 * Provides operational security tools and protections for investigators.
 * Includes secure routing, identity protection, and threat monitoring.
 * Ensures secure and anonymous access to sensitive data.
 */

import { osintApi } from '../api/osintApi';
import osintEndpoints from '../api/endpoints';
import { createErrorDetail, ErrorDetail } from '../../types/errors';

/**
 * Routing method types
 */
export type RoutingMethod = 
  | 'direct'      // Direct connection (unsecured)
  | 'vpn'         // VPN connection
  | 'tor'         // Tor network
  | 'tor+vpn';    // Tor over VPN (maximum security)

/**
 * Security level types
 */
export type SecurityLevel = 
  | 'standard'    // Basic protection
  | 'enhanced'    // Enhanced protection
  | 'maximum';    // Maximum protection

/**
 * Alert types
 */
export type SecurityAlertType = 
  | 'info'        // Informational
  | 'warning'     // Warning
  | 'critical';   // Critical

/**
 * Security alert
 */
export interface SecurityAlert {
  id: number;
  type: SecurityAlertType;
  message: string;
  time: string;
  acknowledged: boolean;
  details?: Record<string, unknown>;
  isSystemGenerated?: boolean; // Indicates an alert generated by the system, not from the server
}

/**
 * Connection status
 */
export interface ConnectionStatus {
  isSecure: boolean;
  routingMethod: RoutingMethod;
  nodeLocation?: string;
  latency: number;
  encryptionActive: boolean;
  fingerprintProtection: boolean;
  proxyIp?: string;
  dnsSecure: boolean;
  errorMessage?: string;  // Optional error message when there's an issue
}

/**
 * Threat scan result
 */
export interface ThreatScanResult {
  threatLevel: 'none' | 'low' | 'medium' | 'high' | 'critical';
  exposurePoints: string[];
  recommendations: string[];
  details: Record<string, unknown>;
}

/**
 * Security check
 */
export interface SecurityCheck {
  id: string;
  name: string;
  status: 'passed' | 'failed' | 'warning' | 'pending';
  details?: string;
  lastRun: string;
}

/**
 * OPSEC Service class
 */
class OPSECService {
  // Map of retry attempts by operation
  private retryAttempts: Record<string, number> = {};
  
  // Maximum retry attempts
  private MAX_RETRIES = 3;
  
  // Backoff time in milliseconds (starts at 1s, doubles each retry)
  private BASE_BACKOFF_MS = 1000;
  
  // Store system-generated alerts
  private systemAlerts: SecurityAlert[] = [];
  
  /**
   * Track retry attempts and calculate backoff time
   */
  private trackRetryAttempt(operation: string): { attemptCount: number, backoffMs: number } {
    // Initialize retry count if not present
    if (!this.retryAttempts[operation]) {
      this.retryAttempts[operation] = 0;
    }
    
    // Increment retry count
    this.retryAttempts[operation]++;
    
    // Calculate backoff time with exponential backoff (1s, 2s, 4s, etc.)
    const backoffMs = this.BASE_BACKOFF_MS * Math.pow(2, this.retryAttempts[operation] - 1);
    
    return { 
      attemptCount: this.retryAttempts[operation],
      backoffMs
    };
  }
  
  /**
   * Reset retry counter for an operation
   */
  private resetRetryCounter(operation: string): void {
    this.retryAttempts[operation] = 0;
  }
  
  /**
   * Create system-generated alert for service errors
   */
  private createErrorAlert(message: string, errorDetail?: ErrorDetail): SecurityAlert {
    // Use descriptive message or fallback
    const alertMessage = message || 'An error occurred while connecting to security services';
    
    return {
      id: Date.now(), // Use timestamp as ID
      type: 'warning',
      message: alertMessage,
      time: 'Just now',
      acknowledged: false,
      details: {
        errorType: errorDetail?.category || 'unknown',
        timestamp: new Date().toISOString(),
        recoveryAction: 'Using cached data. Try refreshing later.',
        ...errorDetail?.context
      },
      isSystemGenerated: true
    };
  }
  
  /**
   * Get current connection status
   */
  async getConnectionStatus(retry = false): Promise<ConnectionStatus> {
    const operation = 'getConnectionStatus';
    
    try {
      // If in development mode, return mock data
      if (process.env.NODE_ENV === 'development') {
        return this.getMockConnectionStatus();
      }
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);
      
      // Add timeout to request options
      const options = { 
        timeout: 15000,
        signal: controller.signal
      };
      
      try {
        const result = await osintApi.get<ConnectionStatus>(
          osintEndpoints.opsec.secureRoute,
          options
        );
        
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Reset retry counter on success
        this.resetRetryCounter(operation);
        
        if (result.success && result.data) {
          return result.data;
        }
        
        // If we have an error detail, create a more descriptive error message
        if (result.errorDetail) {
          throw new Error(result.errorDetail.message || result.error || 'Failed to get connection status');
        }
        
        throw new Error(result.error || 'Failed to get connection status: Unknown error');
      } catch (abortError) {
        clearTimeout(timeoutId);
        throw abortError;
      }
    } catch (error) {
      console.error('[OPSECService] Error getting connection status:', error);
      
      // Track retry attempt and get backoff time
      const { attemptCount, backoffMs } = this.trackRetryAttempt(operation);
      
      // If we haven't exceeded max retries and retry flag is true, attempt retry
      if (retry && attemptCount <= this.MAX_RETRIES) {
        console.log(`[OPSECService] Retrying getConnectionStatus (${attemptCount}/${this.MAX_RETRIES}) after ${backoffMs}ms`);
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Attempt retry
        return this.getConnectionStatus(true);
      }
      
      // Return fallback data with error indicator
      const fallbackData = this.getMockConnectionStatus();
      const errorMessage = error instanceof Error 
        ? error.message 
        : 'Unknown error occurred while getting connection status';
        
      return {
        ...fallbackData,
        isSecure: false,
        errorMessage: errorMessage,
      };
    }
  }
  
  /**
   * Get security alerts
   */
  async getSecurityAlerts(retry = false): Promise<SecurityAlert[]> {
    const operation = 'getSecurityAlerts';
    
    try {
      // If in development mode, return mock data
      if (process.env.NODE_ENV === 'development') {
        return this.getMockSecurityAlerts();
      }
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      try {
        const result = await osintApi.get<SecurityAlert[]>(
          '/opsec/alerts',
          { 
            timeout: 10000,
            signal: controller.signal
          }
        );
        
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Reset retry counter on success
        this.resetRetryCounter(operation);
        
        if (result.success && result.data) {
          return result.data;
        }
        
        // Handle specific error cases with more detailed messages
        if (result.status === 404) {
          throw new Error('Security alert system is currently unavailable');
        }
        
        if (result.errorDetail) {
          throw new Error(result.errorDetail.message || 'Failed to retrieve security alerts');
        }
        
        throw new Error(result.error || 'Failed to get security alerts: Server returned unsuccessful response');
      } catch (fetchError) {
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Handle timeout specifically
        if (fetchError instanceof DOMException && fetchError.name === 'AbortError') {
          throw new Error('Security alert system request timed out after 10 seconds');
        }
        
        throw fetchError;
      }
    } catch (error) {
      console.error('[OPSECService] Error getting security alerts:', error);
      
      // Track retry attempt and get backoff time
      const { attemptCount, backoffMs } = this.trackRetryAttempt(operation);
      
      // If we haven't exceeded max retries and retry flag is true, attempt retry
      if (retry && attemptCount <= this.MAX_RETRIES) {
        console.log(`[OPSECService] Retrying getSecurityAlerts (${attemptCount}/${this.MAX_RETRIES}) after ${backoffMs}ms`);
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Attempt retry
        return this.getSecurityAlerts(true);
      }
      
      // Generate a system alert about the failure
      const mockAlerts = this.getMockSecurityAlerts();
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      
      // Create error detail for better tracking
      const errorDetail = createErrorDetail(
        errorMessage,
        {
          operation,
          component: 'OPSECService',
          category: error instanceof TypeError && errorMessage.includes('network') ? 
            'network' : 'unknown',
          retryCount: attemptCount,
          context: {
            lastAttempt: new Date().toISOString(),
            maxRetries: this.MAX_RETRIES
          }
        }
      );
      
      // Add an error alert to inform the user
      const systemAlert = this.createErrorAlert(
        `Security alert system communication error: ${errorMessage}`,
        errorDetail
      );
      
      // Return mock data with system alert about the error
      return [systemAlert, ...mockAlerts];
    }
  }
  
  /**
   * Set routing method
   */
  async setRoutingMethod(method: RoutingMethod, retry = false): Promise<boolean> {
    const operation = 'setRoutingMethod';
    
    try {
      // If in development mode, return mock data
      if (process.env.NODE_ENV === 'development') {
        return true;
      }
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);
      
      try {
        const result = await osintApi.post(
          osintEndpoints.opsec.secureRoute, 
          { method },
          { 
            timeout: 15000,
            signal: controller.signal
          }
        );
        
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Reset retry counter on success
        this.resetRetryCounter(operation);
        
        if (result.success) {
          return true;
        }
        
        // Specific error handling based on response status
        if (result.status === 403) {
          throw new Error(`You don't have permission to change routing method to ${method}`);
        }
        
        throw new Error(result.error || `Failed to set routing method to ${method}`);
      } catch (fetchError) {
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Handle timeout specifically
        if (fetchError instanceof DOMException && fetchError.name === 'AbortError') {
          throw new Error(`Changing routing method to ${method} timed out after 15 seconds`);
        }
        
        throw fetchError;
      }
    } catch (error) {
      console.error(`[OPSECService] Error setting routing method to ${method}:`, error);
      
      // Track retry attempt and get backoff time
      const { attemptCount, backoffMs } = this.trackRetryAttempt(operation);
      
      // If we haven't exceeded max retries and retry flag is true, attempt retry
      if (retry && attemptCount <= this.MAX_RETRIES) {
        console.log(`[OPSECService] Retrying setRoutingMethod (${attemptCount}/${this.MAX_RETRIES}) after ${backoffMs}ms`);
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Attempt retry
        return this.setRoutingMethod(method, true);
      }
      
      return false;
    }
  }
  
  /**
   * Set security level
   */
  async setSecurityLevel(level: SecurityLevel, retry = false): Promise<boolean> {
    const operation = 'setSecurityLevel';
    
    try {
      // If in development mode, return mock data
      if (process.env.NODE_ENV === 'development') {
        return true;
      }
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      try {
        const result = await osintApi.post(
          '/opsec/security-level', 
          { level },
          { 
            timeout: 10000,
            signal: controller.signal
          }
        );
        
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Reset retry counter on success
        this.resetRetryCounter(operation);
        
        if (result.success) {
          return true;
        }
        
        throw new Error(result.error || `Failed to set security level to ${level}`);
      } catch (fetchError) {
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Handle timeout specifically
        if (fetchError instanceof DOMException && fetchError.name === 'AbortError') {
          throw new Error(`Changing security level to ${level} timed out after 10 seconds`);
        }
        
        throw fetchError;
      }
    } catch (error) {
      console.error(`[OPSECService] Error setting security level to ${level}:`, error);
      
      // Track retry attempt and get backoff time
      const { attemptCount, backoffMs } = this.trackRetryAttempt(operation);
      
      // If we haven't exceeded max retries and retry flag is true, attempt retry
      if (retry && attemptCount <= this.MAX_RETRIES) {
        console.log(`[OPSECService] Retrying setSecurityLevel (${attemptCount}/${this.MAX_RETRIES}) after ${backoffMs}ms`);
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Attempt retry
        return this.setSecurityLevel(level, true);
      }
      
      return false;
    }
  }
  
  /**
   * Toggle fingerprint protection
   */
  async setFingerprintProtection(enabled: boolean, retry = false): Promise<boolean> {
    const operation = 'setFingerprintProtection';
    
    try {
      // If in development mode, return mock data
      if (process.env.NODE_ENV === 'development') {
        return true;
      }
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      try {
        const result = await osintApi.post(
          '/opsec/fingerprint-protection', 
          { enabled },
          { 
            timeout: 10000,
            signal: controller.signal
          }
        );
        
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Reset retry counter on success
        this.resetRetryCounter(operation);
        
        if (result.success) {
          return true;
        }
        
        throw new Error(result.error || `Failed to ${enabled ? 'enable' : 'disable'} fingerprint protection`);
      } catch (fetchError) {
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Handle timeout specifically
        if (fetchError instanceof DOMException && fetchError.name === 'AbortError') {
          throw new Error(`${enabled ? 'Enabling' : 'Disabling'} fingerprint protection timed out after 10 seconds`);
        }
        
        throw fetchError;
      }
    } catch (error) {
      console.error(`[OPSECService] Error ${enabled ? 'enabling' : 'disabling'} fingerprint protection:`, error);
      
      // Track retry attempt and get backoff time
      const { attemptCount, backoffMs } = this.trackRetryAttempt(operation);
      
      // If we haven't exceeded max retries and retry flag is true, attempt retry
      if (retry && attemptCount <= this.MAX_RETRIES) {
        console.log(`[OPSECService] Retrying setFingerprintProtection (${attemptCount}/${this.MAX_RETRIES}) after ${backoffMs}ms`);
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Attempt retry
        return this.setFingerprintProtection(enabled, true);
      }
      
      return false;
    }
  }
  
  /**
   * Scan for security threats
   */
  async scanForThreats(retry = false): Promise<ThreatScanResult> {
    const operation = 'scanForThreats';
    
    try {
      // If in development mode, return mock data
      if (process.env.NODE_ENV === 'development') {
        return this.getMockThreatScanResult();
      }
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);
      
      try {
        const result = await osintApi.get<ThreatScanResult>(
          osintEndpoints.opsec.threatScan,
          { 
            timeout: 15000,
            signal: controller.signal
          }
        );
        
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Reset retry counter on success
        this.resetRetryCounter(operation);
        
        if (result.success && result.data) {
          return result.data;
        }
        
        throw new Error(result.error || 'Failed to scan for threats: Server returned unsuccessful response');
      } catch (fetchError) {
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Handle timeout specifically
        if (fetchError instanceof DOMException && fetchError.name === 'AbortError') {
          throw new Error('Security threat scan timed out after 15 seconds');
        }
        
        throw fetchError;
      }
    } catch (error) {
      console.error('[OPSECService] Error scanning for threats:', error);
      
      // Track retry attempt and get backoff time
      const { attemptCount, backoffMs } = this.trackRetryAttempt(operation);
      
      // If we haven't exceeded max retries and retry flag is true, attempt retry
      if (retry && attemptCount <= this.MAX_RETRIES) {
        console.log(`[OPSECService] Retrying scanForThreats (${attemptCount}/${this.MAX_RETRIES}) after ${backoffMs}ms`);
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Attempt retry
        return this.scanForThreats(true);
      }
      
      // Return fallback threat scan with warning
      const mockResult = this.getMockThreatScanResult();
      return {
        ...mockResult,
        threatLevel: 'medium', // Increase threat level as a precaution
        exposurePoints: [
          ...mockResult.exposurePoints,
          'Security scan service communication failure'
        ],
        recommendations: [
          ...mockResult.recommendations,
          'Retry scan when network connectivity improves',
          'Consider using enhanced protection until scan can complete'
        ]
      };
    }
  }
  
  /**
   * Check identity protection
   */
  async checkIdentity(retry = false): Promise<Record<string, unknown>> {
    const operation = 'checkIdentity';
    
    try {
      // If in development mode, return mock data
      if (process.env.NODE_ENV === 'development') {
        return this.getMockIdentityCheck();
      }
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 12000);
      
      try {
        const result = await osintApi.get<Record<string, unknown>>(
          osintEndpoints.opsec.identityCheck,
          { 
            timeout: 12000,
            signal: controller.signal
          }
        );
        
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Reset retry counter on success
        this.resetRetryCounter(operation);
        
        if (result.success && result.data) {
          return result.data;
        }
        
        throw new Error(result.error || 'Failed to check identity: Server returned unsuccessful response');
      } catch (fetchError) {
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Handle timeout specifically
        if (fetchError instanceof DOMException && fetchError.name === 'AbortError') {
          throw new Error('Identity check timed out after 12 seconds');
        }
        
        throw fetchError;
      }
    } catch (error) {
      console.error('[OPSECService] Error checking identity:', error);
      
      // Track retry attempt and get backoff time
      const { attemptCount, backoffMs } = this.trackRetryAttempt(operation);
      
      // If we haven't exceeded max retries and retry flag is true, attempt retry
      if (retry && attemptCount <= this.MAX_RETRIES) {
        console.log(`[OPSECService] Retrying checkIdentity (${attemptCount}/${this.MAX_RETRIES}) after ${backoffMs}ms`);
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Attempt retry
        return this.checkIdentity(true);
      }
      
      // Return fallback identity check with warning
      const mockResult = this.getMockIdentityCheck();
      return {
        ...mockResult,
        identityProtectionScore: Math.max(30, (mockResult.identityProtectionScore as number) - 40), // Reduce protection score as a warning
        recommendations: [
          ...(mockResult.recommendations as string[]),
          'Identity check service is unavailable - exercise additional caution',
          'Consider changing exit nodes more frequently until service is restored'
        ],
        error: error instanceof Error ? error.message : 'Failed to perform identity check'
      };
    }
  }
  
  /**
   * Generate a new identity
   */
  async generateNewIdentity(retry = false): Promise<boolean> {
    const operation = 'generateNewIdentity';
    
    try {
      // If in development mode, return mock data
      if (process.env.NODE_ENV === 'development') {
        return true;
      }
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);
      
      try {
        const result = await osintApi.post(
          '/opsec/new-identity', 
          {},
          { 
            timeout: 15000,
            signal: controller.signal
          }
        );
        
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Reset retry counter on success
        this.resetRetryCounter(operation);
        
        if (result.success) {
          return true;
        }
        
        throw new Error(result.error || 'Failed to generate new identity: Server returned unsuccessful response');
      } catch (fetchError) {
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Handle timeout specifically
        if (fetchError instanceof DOMException && fetchError.name === 'AbortError') {
          throw new Error('Generating new identity timed out after 15 seconds');
        }
        
        throw fetchError;
      }
    } catch (error) {
      console.error('[OPSECService] Error generating new identity:', error);
      
      // Track retry attempt and get backoff time
      const { attemptCount, backoffMs } = this.trackRetryAttempt(operation);
      
      // If we haven't exceeded max retries and retry flag is true, attempt retry
      if (retry && attemptCount <= this.MAX_RETRIES) {
        console.log(`[OPSECService] Retrying generateNewIdentity (${attemptCount}/${this.MAX_RETRIES}) after ${backoffMs}ms`);
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Attempt retry
        return this.generateNewIdentity(true);
      }
      
      // Generate a system alert about the failure
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      
      // Create error detail for better tracking
      const errorDetail = createErrorDetail(
        errorMessage,
        {
          operation,
          component: 'OPSECService',
          category: error instanceof TypeError && errorMessage.includes('network') ? 
            'network' : 'unknown',
          retryCount: attemptCount,
          context: {
            lastAttempt: new Date().toISOString(),
            maxRetries: this.MAX_RETRIES
          }
        }
      );
      
      // Add an error alert to inform the user
      const systemAlert = this.createErrorAlert(
        `Failed to generate new identity: ${errorMessage}`,
        errorDetail
      );
      
      // Attempt to add the alert to the current alerts
      try {
        // We'll create a class property to store system alerts
        if (!this.systemAlerts) {
          this.systemAlerts = [];
        }
        
        this.systemAlerts.push(systemAlert);
      } catch (e) {
        console.error('Failed to add system alert:', e);
      }
      
      return false;
    }
  }
  
  /**
   * Run security checks
   */
  async runSecurityChecks(retry = false): Promise<SecurityCheck[]> {
    const operation = 'runSecurityChecks';
    
    try {
      // If in development mode, return mock data
      if (process.env.NODE_ENV === 'development') {
        return this.getMockSecurityChecks();
      }
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 20000);
      
      try {
        const result = await osintApi.get<SecurityCheck[]>(
          '/opsec/security-checks',
          { 
            timeout: 20000,
            signal: controller.signal
          }
        );
        
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Reset retry counter on success
        this.resetRetryCounter(operation);
        
        if (result.success && result.data) {
          return result.data;
        }
        
        throw new Error(result.error || 'Failed to run security checks: Server returned unsuccessful response');
      } catch (fetchError) {
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Handle timeout specifically
        if (fetchError instanceof DOMException && fetchError.name === 'AbortError') {
          throw new Error('Security checks timed out after 20 seconds');
        }
        
        throw fetchError;
      }
    } catch (error) {
      console.error('[OPSECService] Error running security checks:', error);
      
      // Track retry attempt and get backoff time
      const { attemptCount, backoffMs } = this.trackRetryAttempt(operation);
      
      // If we haven't exceeded max retries and retry flag is true, attempt retry
      if (retry && attemptCount <= this.MAX_RETRIES) {
        console.log(`[OPSECService] Retrying runSecurityChecks (${attemptCount}/${this.MAX_RETRIES}) after ${backoffMs}ms`);
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Attempt retry
        return this.runSecurityChecks(true);
      }
      
      // Get mock checks but modify to indicate service failure
      const mockChecks = this.getMockSecurityChecks();
      
      // Add a failed check for the security check service itself
      const serviceFailureCheck: SecurityCheck = {
        id: 'security-service',
        name: 'Security Check Service',
        status: 'failed',
        details: `Security check service unavailable: ${error instanceof Error ? error.message : 'Unknown error'}`,
        lastRun: new Date().toISOString()
      };
      
      // Return combined checks with the service failure check first
      return [serviceFailureCheck, ...mockChecks];
    }
  }
  
  /**
   * Acknowledge security alert
   */
  async acknowledgeAlert(id: number, retry = false): Promise<boolean> {
    const operation = 'acknowledgeAlert';
    
    try {
      // If in development mode, return mock data
      if (process.env.NODE_ENV === 'development') {
        // Check if it's a system-generated alert
        const systemAlertIndex = this.systemAlerts.findIndex(alert => alert.id === id);
        if (systemAlertIndex !== -1) {
          // Update the alert in our local system alerts
          this.systemAlerts[systemAlertIndex] = {
            ...this.systemAlerts[systemAlertIndex],
            acknowledged: true
          };
        }
        return true;
      }
      
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      try {
        const result = await osintApi.post(
          '/opsec/acknowledge-alert', 
          { id },
          { 
            timeout: 10000,
            signal: controller.signal
          }
        );
        
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Reset retry counter on success
        this.resetRetryCounter(operation);
        
        if (result.success) {
          return true;
        }
        
        throw new Error(result.error || 'Failed to acknowledge alert: Server returned unsuccessful response');
      } catch (fetchError) {
        // Clear timeout
        clearTimeout(timeoutId);
        
        // Handle timeout specifically
        if (fetchError instanceof DOMException && fetchError.name === 'AbortError') {
          throw new Error('Acknowledging alert timed out after 10 seconds');
        }
        
        throw fetchError;
      }
    } catch (error) {
      console.error(`[OPSECService] Error acknowledging alert ${id}:`, error);
      
      // Track retry attempt and get backoff time
      const { attemptCount, backoffMs } = this.trackRetryAttempt(operation);
      
      // If we haven't exceeded max retries and retry flag is true, attempt retry
      if (retry && attemptCount <= this.MAX_RETRIES) {
        console.log(`[OPSECService] Retrying acknowledgeAlert (${attemptCount}/${this.MAX_RETRIES}) after ${backoffMs}ms`);
        
        // Wait for backoff period
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        
        // Attempt retry
        return this.acknowledgeAlert(id, true);
      }
      
      return false;
    }
  }
  
  // ==========================================================================
  // Mock data methods for development
  // ==========================================================================
  
  /**
   * Get mock connection status
   */
  private getMockConnectionStatus(): ConnectionStatus {
    return {
      isSecure: true,
      routingMethod: 'vpn',
      nodeLocation: 'London, UK',
      latency: 120,
      encryptionActive: true,
      fingerprintProtection: true,
      proxyIp: '85.143.224.25',
      dnsSecure: true,
    };
  }
  
  /**
   * Get mock security alerts
   */
  private getMockSecurityAlerts(): SecurityAlert[] {
    return [
      {
        id: 1,
        type: 'warning',
        message: 'Current IP address has been used for 4+ hours',
        time: '10 min ago',
        acknowledged: false,
      },
      {
        id: 2,
        type: 'info',
        message: 'VPN connection established via London node',
        time: '35 min ago',
        acknowledged: true,
      },
      {
        id: 3,
        type: 'critical',
        message: 'Potential DNS leak detected and blocked',
        time: '1 hour ago',
        acknowledged: false,
        details: {
          leakType: 'DNS',
          requestedDomain: 'example.com',
          leakedTo: 'ISP DNS Server',
        },
      },
      {
        id: 4,
        type: 'warning',
        message: 'Browser fingerprint changed from last session',
        time: '2 hours ago',
        acknowledged: true,
      },
      {
        id: 5,
        type: 'info',
        message: 'Secure routing verified and optimized',
        time: '3 hours ago',
        acknowledged: true,
      },
    ];
  }
  
  /**
   * Get mock threat scan result
   */
  private getMockThreatScanResult(): ThreatScanResult {
    return {
      threatLevel: 'low',
      exposurePoints: [
        'Browser fingerprint partially trackable',
        'WebRTC leak potential detected',
      ],
      recommendations: [
        'Enable enhanced fingerprint protection',
        'Disable WebRTC in browser settings',
        'Consider switching to Tor routing for this session',
      ],
      details: {
        fingerprintRisk: 'medium',
        webrtcRisk: 'medium',
        dnsRisk: 'low',
        ipLeakRisk: 'low',
      },
    };
  }
  
  /**
   * Get mock identity check
   */
  private getMockIdentityCheck(): Record<string, unknown> {
    return {
      visible: {
        ip: '85.143.224.25',
        location: 'London, UK',
        isp: 'Private VPN Service',
        hostname: 'vpn-out-123.provider.net',
      },
      actual: {
        location: 'Data protected',
        isp: 'Data protected',
      },
      identityProtectionScore: 85,
      recommendations: [
        'Rotate exit node for improved anonymity',
        'Consider using Tor for enhanced protection',
      ],
    };
  }
  
  /**
   * Get mock security checks
   */
  private getMockSecurityChecks(): SecurityCheck[] {
    return [
      {
        id: 'dns-leak',
        name: 'DNS Leak Test',
        status: 'passed',
        details: 'No DNS leaks detected',
        lastRun: new Date().toISOString(),
      },
      {
        id: 'ip-leak',
        name: 'IP Leak Test',
        status: 'passed',
        details: 'No IP leaks detected',
        lastRun: new Date().toISOString(),
      },
      {
        id: 'browser-fingerprint',
        name: 'Browser Fingerprint Test',
        status: 'warning',
        details: 'Fingerprint partially identifiable',
        lastRun: new Date().toISOString(),
      },
      {
        id: 'webrtc-leak',
        name: 'WebRTC Leak Test',
        status: 'warning',
        details: 'WebRTC potentially leaking information',
        lastRun: new Date().toISOString(),
      },
      {
        id: 'https',
        name: 'HTTPS Check',
        status: 'passed',
        details: 'All connections using HTTPS',
        lastRun: new Date().toISOString(),
      },
    ];
  }
}

// Export the service instance
export const opsecService = new OPSECService();
