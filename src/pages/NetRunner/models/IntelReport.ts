/**
 * IntelReport.ts
 * 
 * This module defines the structure of Intel Reports in the Starcom environment.
 * Intel Reports are tradable commodities on the Intelligence Exchange Marketplace.
 */

import { v4 as uuidv4 } from 'uuid';
import { IntelType } from '../tools/NetRunnerPowerTools';

// Classification levels for Intel
export type ClassificationLevel = 
  | 'UNCLASSIFIED' 
  | 'CONFIDENTIAL' 
  | 'SECRET' 
  | 'TOP_SECRET' 
  | 'COSMIC';

// Verification levels for Intel
export type VerificationLevel = 
  | 'UNVERIFIED'      // Raw intel without verification
  | 'SINGLE_SOURCE'   // Verified by a single source
  | 'MULTI_SOURCE'    // Verified by multiple sources
  | 'CONFIRMED'       // Thoroughly verified and confirmed
  | 'VALIDATED';      // Verified, confirmed, and validated by experts

// Intel Report structure
export interface IntelReport {
  // Core metadata
  id: string;                       // Unique report identifier
  title: string;                    // Report title
  subtitle?: string;                // Optional subtitle
  summary: string;                  // Brief summary
  description: string;              // Detailed description
  
  // Classification and verification
  classification: ClassificationLevel;
  verificationLevel: VerificationLevel;
  
  // Temporal information
  createdAt: string;                // ISO date string
  updatedAt: string;                // ISO date string
  reportPeriod?: {                  // Time period the report covers
    start: string;                  // ISO date string
    end: string;                    // ISO date string
  };
  
  // Geospatial information
  coordinates?: {                   // Geolocation
    lat: number;
    lng: number;
  };
  region?: string;                  // Geographic region
  
  // Content and structure
  intelTypes: IntelType[];          // Types of intelligence in the report
  content: IntelContent[];          // Report sections
  entities: IntelEntity[];          // Extracted entities
  relationships: IntelRelationship[]; // Entity relationships
  evidence: Evidence[];             // Supporting evidence
  
  // Attribution and source
  author: string;                   // Author's identifier
  authorName: string;               // Display name of author
  sources: Source[];                // Information sources
  
  // Market and trading
  marketValue: number;              // Current market value
  tradable: boolean;                // Whether it can be traded
  exchangeStatus: 'DRAFT' | 'LISTED' | 'SOLD' | 'ARCHIVED';
  
  // Technical
  hash: string;                     // Cryptographic hash of content
  signature?: string;               // Author's cryptographic signature
  encryptionStatus: 'UNENCRYPTED' | 'ENCRYPTED';
  ipfsHash?: string;                // IPFS location if stored on IPFS
  
  // Tags and categorization
  tags: string[];                   // Searchable tags
  categories: string[];             // Categories
  
  // Meta
  toolsUsed?: string[];             // NetRunner tools used to generate
  botGenerated?: boolean;           // Whether generated by BotRoster bot
  botId?: string;                   // ID of generating bot if applicable
}

// Intel content section
export interface IntelContent {
  id: string;
  title: string;
  type: 'text' | 'image' | 'table' | 'graph' | 'link' | 'file' | 'code';
  content: string;
  order: number;
  metadata?: Record<string, unknown>;
}

// Intelligence entity
export interface IntelEntity {
  id: string;
  name: string;
  type: string;                     // Person, organization, device, etc.
  identifiers?: Record<string, string>; // Known identifiers (emails, etc)
  properties?: Record<string, unknown>; // Additional properties
  confidence: number;               // Confidence score (0-1)
  sources: string[];                // Source IDs
}

// Entity relationship
export interface IntelRelationship {
  id: string;
  source: string;                   // Source entity ID
  target: string;                   // Target entity ID
  type: string;                     // Relationship type
  properties?: Record<string, unknown>; // Additional properties
  confidence: number;               // Confidence score (0-1)
  sources: string[];                // Source IDs
}

// Evidence supporting the intelligence
export interface Evidence {
  id: string;
  type: 'document' | 'image' | 'video' | 'audio' | 'log' | 'data';
  title: string;
  description: string;
  url?: string;                     // URL if available online
  hash?: string;                    // Hash of the evidence
  timestamp: string;                // When the evidence was collected
  metadata?: Record<string, unknown>;
}

// Information source
export interface Source {
  id: string;
  name: string;
  type: 'human' | 'technical' | 'open_source' | 'classified';
  reliability: 'A' | 'B' | 'C' | 'D' | 'E' | 'F'; // Standard reliability scale
  url?: string;
  notes?: string;
}

// Factory function for creating a new Intel Report
export const createIntelReport = (
  title: string,
  summary: string,
  description: string,
  authorId: string,
  authorName: string,
  classification: ClassificationLevel = 'UNCLASSIFIED',
  intelTypes: IntelType[] = ['identity']
): IntelReport => {
  const now = new Date().toISOString();
  
  return {
    id: uuidv4(),
    title,
    summary,
    description,
    classification,
    verificationLevel: 'UNVERIFIED',
    createdAt: now,
    updatedAt: now,
    intelTypes,
    content: [],
    entities: [],
    relationships: [],
    evidence: [],
    author: authorId,
    authorName,
    sources: [],
    marketValue: 0,
    tradable: false,
    exchangeStatus: 'DRAFT',
    hash: '',  // Will be computed when finalized
    encryptionStatus: 'UNENCRYPTED',
    tags: [],
    categories: []
  };
};

// Function to finalize an Intel Report
export const finalizeIntelReport = (report: IntelReport): IntelReport => {
  // Create a deep copy to avoid modifying the original
  const finalReport = JSON.parse(JSON.stringify(report)) as IntelReport;
  
  // Update timestamp
  finalReport.updatedAt = new Date().toISOString();
  
  // Calculate hash (in a real implementation, this would use a cryptographic hash function)
  finalReport.hash = `hash_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  
  // Set as tradable if it meets minimum requirements
  finalReport.tradable = 
    finalReport.content.length > 0 &&
    finalReport.entities.length > 0 &&
    finalReport.verificationLevel !== 'UNVERIFIED';
  
  // Set market value based on various factors
  // This is a simplified placeholder calculation
  const baseValue = 50;
  const classificationMultiplier = {
    'UNCLASSIFIED': 1,
    'CONFIDENTIAL': 1.5,
    'SECRET': 2.5,
    'TOP_SECRET': 4,
    'COSMIC': 10
  };
  
  const verificationMultiplier = {
    'UNVERIFIED': 0.5,
    'SINGLE_SOURCE': 1,
    'MULTI_SOURCE': 1.5,
    'CONFIRMED': 2,
    'VALIDATED': 3
  };
  
  const contentValue = finalReport.content.length * 5;
  const entityValue = finalReport.entities.length * 3;
  const relationshipValue = finalReport.relationships.length * 2;
  const evidenceValue = finalReport.evidence.length * 10;
  
  finalReport.marketValue = Math.round(
    baseValue * 
    classificationMultiplier[finalReport.classification] * 
    verificationMultiplier[finalReport.verificationLevel] +
    contentValue +
    entityValue +
    relationshipValue +
    evidenceValue
  );
  
  // Update status
  finalReport.exchangeStatus = 'LISTED';
  
  return finalReport;
};
